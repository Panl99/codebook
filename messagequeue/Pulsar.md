[Apache Pulsar 从入门到实践](https://mp.weixin.qq.com/s/N7UZchlkkJLB6BsBuOny1g)

# Pulsar简介

## Pulsar是什么
Pulsar 是灵活的发布-订阅消息系统，采用分层分片架构。
用于服务器到服务器消息传递的多租户、高性能解决方案。

## Pulsar的特点
- Pulsar 的单个实例原生支持多个集群，可跨机房在集群间无缝地完成消息复制。
- 极低的发布延迟和端到端延迟。
- 可无缝扩展到超过一百万个 topic。
- 简单的客户端 API，支持 Java、Go、Python 和 C++。
- Topic 支持多种订阅模式（独占订阅、共享订阅、故障转移订阅）。
- 通过 Apache BookKeeper 提供的持久化消息存储机制保证消息传递 。
- 由轻量级的 serverless 计算框架 Pulsar Functions 实现流原生的数据处理。
- 基于 Pulsar Functions 的 serverless connector 框架 Pulsar IO 使得数据更易移入、移出 Apache Pulsar。
- 分层式存储可在数据陈旧时，将数据从热存储卸载到冷/长期存储（如S3、GCS）中。

多租户：  
租户（tenant）和命名空间（namespace）是 Pulsar 支持多租户的两个核心概念。
- 在租户级别，Pulsar 为特定的租户预留合适的存储空间、应用授权与认证机制。
- 在命名空间级别，Pulsar 有一系列的配置策略（policy），包括存储配额、流控、消息过期策略和命名空间之间的隔离策略。

灵活的消息系统：  
Pulsar 做了队列模型和流模型的统一，在 Topic 级别只需保存一份数据，同一份数据可多次消费。以流式、队列等方式计算不同的订阅模型大大提升了灵活度。

多种订阅类型：  
- 独享（exclusive）订阅：同时只能有一个消费者。
- 共享（shared）订阅：可以由多个消费者订阅，每个消费者接收其中的一部分消息。
- 故障转移（failover）订阅：允许多个消费者连接到同一个主题上，但只有一个消费者能够接收消息。只有在当前消费者发生失效时，其他消费者才开始接收消息。

云原生架构：  
Pulsar 使用计算与存储分离的云原生架构，数据从 Broker 搬离，存在共享存储内部。
上层是无状态 Broker，复制消息分发和服务；下层是持久化的存储层 Bookie 集群。
Pulsar 存储是分片的，这种构架可以避免扩容时受限制，实现数据的独立扩展和快速恢复。

Segmented Streams：  
Pulsar 将无界的数据看作是分片的流，分片分散存储在分层存储（tiered storage）、BookKeeper 集群和 Broker 节点上，而对外提供一个统一的、无界数据的视图。
其次，不需要用户显式迁移数据，减少存储成本并保持近似无限的存储。

跨地域复制：  
Pulsar 中的跨地域复制是将 Pulsar 中持久化的消息在多个集群间备份。
在 Pulsar 2.4.0 中新增了复制订阅模式(Replicated-subscriptions)，在某个集群失效情况下，该功能可以在其他集群恢复消费者的消费状态，从而达到热备模式下消息服务的高可用。

层级存储：  
层级存储的优势：
- Infinite Stream: 以流的方式永久保存原始数据
- 分区的容量不再受限
- 充分利⽤云存储或现有的廉价存储 ( 例如 HDFS)
- 数据统⼀表征：客户端无需关⼼数据究竟存储在哪⾥

Pulsar Functions：  
Pulsar Functions 是一个轻量级的计算框架，可以给用户提供一个部署简单、运维简单、API 简单的 FAAS（Function as a service）平台。  
Pulsar Functions 提供基于事件的服务，支持有状态与无状态的多语言计算，是对复杂的大数据处理框架的有力补充。

Pulsar IO：  
Pulsar IO 分为输入（Input）和输出（Output）两个模块，  
输入代表数据从哪里来，通过 Source 实现数据输入。  
输出代表数据要往哪里去，通过 Sink 实现数据输出。


## 为什么选择Pulsar而不是Kafka？

1. 流式处理和队列的合体。
    - Kafka 或 RabbitMQ 在单个平台上都只能处理其中一种方式。
    - 而 Pulsar 就像一个合二为一的产品，可以同时处理实时流和消息队列。
2. 支持分区，但不是必需的。
    - 如果只需要一个主题，可以使用一个主题而无需使用分区。
    - 如果需要保持多个消费者实例的处理速率，也不需要使用分区。
3. 分布式的日志。
    - Pulsar 日志是分布式的，可以水平扩展。因此不会保存在单台服务器上，任何一台服务器都不会成为整个系统的瓶颈。
4. 无状态的 broker。
    - 云原生应用程序开发的理想场景，数据的分发和保存相互独立。
5. 原生支持跨地域复制，而且配置简单。
    - 无论是全局分布式应用程序还是灾备方案，任何人都可以通过 Pulsar 搞定。
6. 稳定的表现。
    - 基准测试表明，Pulsar 可以在提供较高吞吐量的同时保持较低的延迟。
7. 完全开源。
    - 不论是与 Kafka 相似的特性，还是 Kafka 没有的特性都是开源的。
8. 多租户。
    - 可以为多团队、多项目提供独立的消息系统。
    - 这些租户可以有多个命名空间，以保持内容顺序。再加上每个命名空间的访问控制、配额、速率限制等，可以只使用一个集群就能处理多租户问题。
9. Quorum 复制。
    - 要想确保消息不丢失，消息传递系统会配置每条消息生成 2 或 3 个副本，以防出错。
    - Kafka 使用 follow-the-leader 模型 来实现这一点。Leader 存储消息，而 follower 复制 leader 上的消息。一旦有足够多的 follower 确认已经完成了复制，Kafka 就“高兴”了。
    - Pulsar 使用 Quorum 模型。它把消息发送给一堆节点，一旦有足够多的节点确认它们已经接收到消息，Pulsar 就很“高兴”。
    - Quorum 复制更加民主，没有这种 leader-follower 层次结构。所有选票均等时，多数胜利。但这与技术无关。重要的是，随着时间的推移，Quorum 复制倾向于提供更一致的行为。这或许可以解释为什么 Pulsar 具有更一致的延迟性能。
10. 分层存储。
    - 借助 Pulsar 分层存储，可以把那些旧消息自动推送到几乎无限的、廉价的云存储中，然后像检索新消息一样执行相关操作。

    像 Kafka 这样的流处理系统，其一大优点在于它能够重放已经被消费的消息。如果你第一次见到就很喜欢这些消息，则可以进行重播以更正某些内容，或围绕它们构建新的应用程序，这也是很有趣的。
如果你非常喜欢这些消息，想把它们永远保存下来，那该怎么办？比如，如果你在做事件溯源。这听起来很不错，但永久可是一段很长的时间，而且永久存储消息也可能很贵，特别是存储在高性能固态硬盘上。这些硬盘需要维持消息系统保持良好的运行状态。
如果能把那些旧消息（那些以后可能会再用到的消息）转移到相对便宜的存储解决方案中，是否可行呢？如果可以使用像 Amazon S3 存储桶这样廉价的云存储，那岂不是很棒吗？
11. 端到端加密。
    - Pulsar 可以在其 Java 客户端中进行端到端加密。来保证消息不被偷窥。
    
    生产者在发送消息之前使用与接收消息的使用者共享的密钥对消息进行加密。当消息保存在消息系统的磁盘上时，就会被加密，而消息系统没有密钥。消息传递系统可以完成它的工作，但是你的消息对于消息传递系统来说是就像天书一样，所以是十分安全的。
12. Broker 负载平衡。
    - Pulsar broker 是无状态的。组件无状态是件非常棒的事情，当一个组件过载时，你可以添加另一个组件来处理负载。当新客户端连接时，可以将它们定向到新实例。但这并不能帮助到第一次被重载的实例。你需要将一些工作从重载实例转移到新的实例上。换句话说，需要重新平衡负载。
    - Pulsar 会自动进行 broker 负载平衡。它监视 broker 的 CPU、内存、网络（不是磁盘，我提到的代理是无状态的）的使用情况，并调整负载以保持平衡。这意味着你不需要在单个 broker 热点时扩容 broker 集群，除非 broker 集群服务能力到达上限。

    你也可以使用 Kafka 进行代理负载平衡。但是，你必须多安装一个程序，例如 LinkedIn 的 Cruise Control。或者也可以使用 Confluent 的负载平衡器工具（这款工具是需要付费的）。





# 消息概念
# 架构概述
# 脉冲星客户端
# 地理复制
# 多租户
# 身份验证和授权
# 主题压缩
# 分层存储