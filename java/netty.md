> [Netty实战.pdf](../resources/static/doc/Netty实战.pdf)  
> [github:netty](https://github.com/netty/netty)  


# Netty

Netty是一个异步事件驱动的Java网络应用框架。主要用于开发高性能、高可靠性的网络服务器和客户端。

- 异步通信
- 事件驱动

## Netty特点
- 设计
    - 统一的API，支持多种传输类型，阻塞的和非阻塞的
    - 简单而强大的线程模型
    - 真正的无连接数据报套接字支持
    - 链接逻辑组件以支持复用
- 易于使用
    - 详实的Javadoc和大量的示例集
    - 不需要超过JDK 1.6+③的依赖。（一些可选的特性可能需要Java 1.7+和/或额外的依赖）
- 性能
    - 拥有比Java的核心API更高的吞吐量以及更低的延迟
    - 得益于池化和复用，拥有更低的资源消耗
    - 最少的内存复制
- 健壮性
    - 不会因为慢速、快速或者超载的连接而导致OutOfMemoryError
    - 消除在高速网络中NIO应用程序常见的不公平读/写比率
- 安全性
    - 完整的SSL/TLS以及StartTLS支持
    - 可用于受限环境下，如Applet和OSGI
- 社区驱动
    - 发布快速而且频繁
  

## Netty核心组件

### Channel
Channel 是 Java NIO 的一个基本构造。

它代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O操作的程序组件）的开放连接，如读操作和写操作。

可以把 Channel 看作是传入（入站）或者传出（出站）数据的载体。因此，它可以被打开或者被关闭，连接或者断开连接。

### 回调
一个回调其实就是一个方法，一个指向已经被提供给另外一个方法的方法的引用。这使得后者可以在适当的时候调用前者。

Netty 在内部使用了回调来处理事件；
当一个回调被触发时，相关的事件可以被一个interface：`ChannelHandler` 的实现处理。

### Future
Future 提供了另一种在操作完成时通知应用程序的方式。这个对象可以看作是一个异步操作的结果的占位符；它将在未来的某个时刻完成，并提供对其结果的访问。

JDK 内置的Future所提供的实现，只允许手动检查对应的操作是否已经完成，或者一直阻塞直到它完成。这是非常繁琐的，所以 Netty 提供了它自己的实现：`ChannelFuture`，用于在执行异步操作的时候使用。

ChannelFuture提供了几种额外的方法能够注册一个或者多个ChannelFutureListener实例。
监听器的回调方法operationComplete()，将会在对应的操作完成时被调用。
然后监听器可以判断该操作是成功地完成了还是出错了。如果是后者，可以检索产生的Throwable。
简而言之，由ChannelFutureListener提供的通知机制消除了手动检查对应的操作是否完成的必要。

每个 Netty 的出站 I/O 操作都将返回一个 ChannelFuture；它们都不会阻塞。

### 事件和ChannelHandler
Netty 使用不同的事件来通知我们状态的改变或者是操作的状态。
这使得我们能够基于已经发生的事件来触发适当的动作。这些动作可能是：
- 记录日志；
- 数据转换；
- 流控制；
- 应用程序逻辑。

Netty按照入站 或 出站 数据流的相关性进行分类。
- 由入站数据或者相关的状态更改而触发的事件包括：
  - 连接已被激活或者连接失活；
  - 数据读取；
  - 用户事件；
  - 错误事件。
- 出站事件是未来将会触发的某个动作的操作结果，这些动作包括：
  - 打开或者关闭到远程节点的连接；
  - 将数据写到或者冲刷到套接字。

每个事件都可以被分发给 `ChannelHandler` 类中的某个用户实现的方法。

Netty 提供了大量预定义的可以开箱即用的 ChannelHandler 实现，包括用于各种协议（如 HTTP 和 SSL/TLS）的 ChannelHandler。
在内部，ChannelHandler 自己也使用了事件 和 Future，使得它们也成为了应用程序将使用的相同抽象的消费者。






